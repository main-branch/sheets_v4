# frozen_string_literal: true

require 'logger'
require 'optparse'

# Command line interface parser based on OptionsParser
class CommandLineBoss
  # Create a new command line parser
  #
  # @example
  #   parser = CommandLineParser.new
  #
  # @param program_name [String] the name of the program to report in the usage line
  #
  #   The program name is used in the usage line when the --help option is given.
  #   This is given as an optional argument so that it can be overridden in tests.
  #
  def initialize(program_name: $PROGRAM_NAME)
    @program_name = program_name
    @parser = OptionParser.new
    @error_messages = []
    set_defaults
    define_options
  end

  # Parse the command line arguments and return self
  #
  # @example
  #   parser = CommandLineParser.new.call(ARGV)
  #
  # @param args [Array<String>] the command line arguments
  #
  # @raise [SystemExit] if the command line arguments are invalid
  #
  # @return [CommandLineParser]
  #
  def call(args)
    @args = args.dup
    parse_options
    parse_arguments
    validate if error_messages.empty?
    result
  end

  # The name of the program to report in the usage line
  #
  #   The program name is used in the usage line when the --help option is given.
  #   This is given as an optional argument so that it can be overridden in tests.
  #
  # @example
  #   options.program_name #=> 'sync_paranoids_milestones'
  #
  # @return [String]
  #
  attr_reader :program_name

  private

  # Ensure that any extra args are valid
  #
  # This method is expected to add a message to error_messages if there are
  # any extra arguments.
  #
  # For this command line, there should be no extra arguments.
  #
  # @return [void]
  #
  # @api private
  #
  def validate_remaining_args
    return if args.empty?

    error_messages << "Unexpected arguments: #{args.join(' ')}"
  end

  # The parse to use to parse the command line arguments
  #
  # @return [OptionParser]
  #
  # @api private
  #
  attr_reader :parser

  # The command line args passed to the parser
  #
  # The parser will remove options and their arguments from this array
  # as it parses them.
  #
  # After all options are parsed, this array will contain only the
  # remaining arguments.
  #
  # @return [Array<String>]
  #
  # @api private
  #
  attr_reader :args

  # The error messages generated by the validation methods
  #
  # @return [Array<String>]
  #
  # @api private
  #
  attr_reader :error_messages

  # Parse the command line arguments using the OptionParser
  #
  # The OptionParser will remove options and their arguments from the
  # `args` array as it parses them. After all options are parsed, `args`
  # will contain only the remaining arguments.
  #
  # @raise [SystemExit] if the command line arguments are invalid
  #
  # @return [void]
  #
  # @api private
  #
  def parse_options
    parser.parse!(args)
  rescue OptionParser::InvalidOption => e
    error_messages << e.message
  end

  # Parse the arguments that remain after parsing options
  #
  # This method is expected to be overridden by subclasses to parse the
  # remaining arguments. {args} will contain the remaining arguments. This
  # method should remove any arguments it processes from {args}.
  #
  # @return [void]
  #
  # @api private
  #
  def parse_arguments; end

  # Determine the result to be returned from {#call}
  #
  # If there are no error messages, returns self. Otherwise, outputs the error
  # messages and exits the program with a non-zero status code.
  #
  # @raise [SystemExit] if there are errors
  #
  # @return [CommandLineParser]
  #
  # @api private
  #
  def result
    return self if error_messages.empty?

    warn "ERROR: #{error_messages.join("\nERROR: ")}"
    exit 1
  end

  # Validate the command line options and remaining arguments
  #
  # Calls all validation methods defined by this class. Validation
  # methods are private methods that start with `validate_`.
  #
  # If validation fails, a validation method is expected to output an error
  # messages using `warn` and exit the program with a non-zero status code.
  #
  # @return [void]
  #
  # @api private
  #
  def validate
    private_methods.select { |m| validation_method?(m) }.each { |m| send(m) }
  end

  # Set the default values for the command line options
  #
  # @return [void]
  #
  # @api private
  #
  def set_defaults; end

  # Define the command line options
  #
  # @return [void]
  #
  # @api private
  #
  def define_options
    add_banner
    add_usage
    add_header
    parser.separator 'Options:'
    private_methods.select { |m| definition_method?(m) }.each { |m| send(m) }
    parser.separator ''
    add_footer
  end

  def add_banner
    return unless banner

    parser.banner = banner
    parser.separator ''
  end

  def banner = nil

  def add_usage
    return unless usage

    parser.separator usage
    parser.separator ''
  end

  # Usage text for command line help
  #
  # Override this method in a subclass to provide a custom usage line.
  #
  # It is suggested to use [the Google developer documentation style guide for
  # documenting command-line
  # syntax](https://developers.google.com/style/code-syntax).
  #
  # @return [String]
  #
  # @api private
  #
  def usage = nil

  def add_header
    return unless header

    parser.separator header
    parser.separator ''
  end

  def header = nil

  def add_footer
    return unless footer

    parser.separator footer
    parser.separator ''
  end

  def footer = nil

  # Test if a method is a definition method
  #
  # @param method [Symbol] the method name
  #
  # @return [Boolean]
  #
  # @api private
  #
  def definition_method?(method) = method.start_with?('define_') && method.end_with?('_option')

  # Test if a method is a definition method
  #
  # @param method [Symbol] the method name
  #
  # @return [Boolean]
  #
  # @api private
  #
  def validation_method?(method) = method.start_with?('validate_')
end

class CommandLineBoss
  # Add the --help option
  module HelpOption
    private

    # Define the --help option
    #
    # @return [void]
    #
    # @api private
    #
    def define_help_option
      parser.on('-h', '--help', 'Show this message') do
        puts parser.help
        exit
      end
    end
  end
end

class CommandLineBoss
  # Add --debug and --verbose options and a logger method
  module LoggerOptions
    # true if the --debug option was given
    #
    # @return [Boolean]
    #
    # @api private
    #
    attr_reader :debug

    # true if the --verbose option was given
    #
    # @return [Boolean]
    #
    # @api private
    #
    attr_reader :verbose

    # The logger to use to report progress
    #
    # Messages are logged at info and debug levels. The logger returned is one of
    # the following:
    #
    # * A logger that logs to the console at the :info level if verbose mode is enabled
    # * A logger that logs to the console at the :debug level if debug mode is enabled
    # * Otherwise a null logger that does not log anything
    #
    # @example
    #   options.logger #=> #<Logger:0x00007f9e3b8b3e08>
    #
    # @return [Logger]
    #
    def logger
      @logger ||=
        if verbose
          verbose_logger
        elsif debug
          debug_logger
        else
          Logger.new(nil)
        end
    end

    private

    # Define the --verbose option
    #
    # @return [void]
    #
    # @api private
    #
    def define_verbose_option
      parser.on('-v', '--verbose', 'Enable verbose mode (default is off)') do |verbose|
        @verbose = verbose
      end
    end

    # Define the --debug option
    #
    # @return [void]
    #
    # @api private
    #
    def define_debug_option
      parser.on('-D', '--debug', 'Enable debug mode default is off') do |debug|
        @debug = debug
      end
    end

    # Ensure that the --debug and --verbose options are not both given
    #
    # @return [void]
    #
    # @api private
    #
    def validate_debug_verbose_option
      error_messages << 'Can not give both --debug and --verbose' if debug && verbose
    end

    # A Logger that logs to the console at the :debug level with a simple formatter
    #
    # @return [Logger]
    #
    # @api private
    #
    def debug_logger
      Logger.new($stdout, level: 'debug', formatter: ->(_severity, _datetime, _progname, msg) { "#{msg}\n" })
    end

    # A Logger that logs to the console at the :info level with a simple formatter
    #
    # @return [Logger]
    #
    # @api private
    #
    def verbose_logger
      Logger.new($stdout, level: 'info', formatter: ->(_severity, _datetime, _progname, msg) { "#{msg}\n" })
    end
  end
end
